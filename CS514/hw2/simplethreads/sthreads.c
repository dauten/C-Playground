/* On Mac OS (aka OS X) the ucontext.h functions are deprecated and requires the
   following define.
*/
#define _XOPEN_SOURCE 700

/* On Mac OS when compiling with gcc (clang) the -Wno-deprecated-declarations
   flag must also be used to suppress compiler warnings.
*/
#include <string.h>
#include <signal.h>   /* SIGSTKSZ (default stack size), MINDIGSTKSZ (minimal
                         stack size) */
#include <stdio.h>    /* puts(), printf(), fprintf(), perror(), setvbuf(), _IOLBF,
                         stdout, stderr */
#include <ucontext.h> /* ucontext_t, getcontext(), makecontext(),
                         setcontext(), swapcontext() */
#include "sthreads.h"
#include <stdlib.h>   // exit(), EXIT_FAILURE, EXIT_SUCCESS
#include <signal.h>   // sigaction()
#include <sys/time.h> // ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF, struct itimerval, setitimer()
#include <stdbool.h>  // true, false
#include <limits.h>   // INT_MAX

/* Stack size for each context. */
#define STACK_SIZE SIGSTKSZ*100
#define THREAD_LIMIT 10 //total number of lifetime threads that can exit
#define TIMEOUT    10          // ms
#define TIMER_TYPE ITIMER_REAL // Type of timer.
/*******************************************************************************
                             Global data structures

                Add data structures to manage the threads here.
********************************************************************************/
//Three sample contexts, plus schedular, current global, and list of threads
ucontext_t scheduler;
ucontext_t *current;
static ucontext_t threads[THREAD_LIMIT];
static int num_of_threads = 0;
static int i;
static int yielded = 0;


/*******************************************************************************
                             Auxiliary functions

                      Add internal helper functions here.
********************************************************************************/

/* The three types of timers causes different signals.

   type: type of timer, one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF.

   return value: the signal generated by the timer.

 */
int timer_signal(int timer_type) {
  int sig;

  switch (timer_type) {
    case ITIMER_REAL:
      sig = SIGALRM;
      break;
    case ITIMER_VIRTUAL:
      sig = SIGVTALRM;
      break;
    case ITIMER_PROF:
      sig = SIGPROF;
      break;
    default:
      fprintf(stderr, "ERROR: unknown timer type %d!\n", timer_type);
      exit(EXIT_FAILURE);
  }

  return sig;
}

void preempt();

/* Set a timer and a handler for the timer.

   Arguments

   type: type of timer, one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF.

   handler: timer signal handler.

   ms: time in ms for the timer.

 */
void set_timer(int type, void (*handler) (int), int ms) {
  struct itimerval timer;
  struct sigaction sa;

  /* Install signal handler for the timer. */
  memset (&sa, 0, sizeof (sa));
  sa.sa_handler =  handler;
  sigaction (timer_signal(type), &sa, NULL);

  /* Configure the timer to expire after ms msec... */
  timer.it_value.tv_sec = 0;
  timer.it_value.tv_usec = ms*1000;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 0;

  if (setitimer (type, &timer, NULL) < 0) {
    perror("Setting timer");
    exit(EXIT_FAILURE);
  };
}


/* Timer signal handler. */
void timer_handler (int signum) {
  static int count = 0;
  fprintf (stderr, "======> timer (%03d)\n", count++);
  preempt();
  set_timer(TIMER_TYPE, timer_handler, TIMEOUT);
}

void preempt(){
  if(yielded == 0)
  {
    set_timer(TIMER_TYPE, timer_handler, TIMEOUT);
    i++;
    if(i == num_of_threads) i = 0;
    current = &threads[i];
    swapcontext(&scheduler, &threads[i]);
  }
  yielded = 0;
}




/*
* Scheduler function, when a thread yields or is preempted
* control is brough back to this function to determine and start next thread
*/
void round_robin(){
  while(1){
    for(i = 0 ; i < num_of_threads; i++){
      current = &threads[i];
      swapcontext(&scheduler, &threads[i]);
    }
  }
}

/* Initialize a context.

   ctxt - context to initialize.

   next - successor context to activate when ctx returns. If NULL, the thread
          exits when ctx returns.
 */
void init_context(ucontext_t *ctx) {
  /* Allocate memory to be used as the stack for the context. */
  void *stack = malloc(STACK_SIZE);

  if (stack == NULL) {
    perror("Allocating stack");
    exit(EXIT_FAILURE);
  }

  if (getcontext(ctx) < 0) {
    perror("getcontext");
    exit(EXIT_FAILURE);
  }

  /* Before invoking makecontext(ctx), the caller must allocate a new stack for
     this context and assign its address to ctx->uc_stack, and define a successor
     context and assigns address to ctx->uc_link.
  */

  ctx->uc_link           = NULL;
  ctx->uc_stack.ss_sp    = stack;
  ctx->uc_stack.ss_size  = STACK_SIZE;
  ctx->uc_stack.ss_flags = 0;
}

/* Initialize context ctx  with a call to function func with zero argument.
 */
void init_context0(ucontext_t *ctx, void (*func)(), ucontext_t *next) {
  init_context(ctx);
  makecontext(ctx, func, 0);
}

/* Initialize context ctx with a call to function func with one string argument.
 */
void init_context1(ucontext_t *ctx, void (*func)(), const char *str, ucontext_t *next) {
  init_context(ctx);
  makecontext(ctx, func, 1, str);
}


/*******************************************************************************
                    Implementation of the Simple Threads API
********************************************************************************/

/*
* Start schedular and timers
*/
int init(){
  setvbuf(stdout, 0, _IOLBF, 0);
  init_context0(&scheduler, round_robin, NULL);
  set_timer(TIMER_TYPE, timer_handler, TIMEOUT);
  setcontext(&scheduler);
  return -1; //error, should not return
}

/*
* Create new thread, adding it to schedular
*/
tid_t spawn(void (*start)()){
  init_context0(&threads[num_of_threads], start, NULL);
  num_of_threads++;
  return 1; //true
}

/*
* Set new timer and swap back to schedular
*/
void yield(){
  set_timer(TIMER_TYPE, timer_handler, TIMEOUT);
  yielded = 1;
  swapcontext(current, &scheduler);
}

/*
* Make this thread just yield forever
*/
void done(){
  while(true){
    yield(); //messy and poor form but it works for now, OK?
  }
}

tid_t join() {
  return -1;
}
